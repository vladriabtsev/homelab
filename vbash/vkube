#!/usr/bin/env bash

# This script was generated by bashly 1.2.11 (https://bashly.dev)

# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then

  printf "bash version 4 or higher is required\n" >&2

  exit 1

fi

# :command.master_script

# :command.version_command
version_command() {

  echo "$version"

}

# :command.usage
vkube_usage() {

  printf "vkube - Kubernetes installation\n\n"

  printf "%s\n" "$(bold "Usage:")"

  printf "  vkube [OPTIONS] COMMAND\n"

  printf "  vkube [COMMAND] --help | -h\n"

  printf "  vkube --version | -v\n"

  echo

  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"

  printf "  %s   Kubernetes and all services\n" "$(green "all") "
  printf "  %s   k3s kubernetes\n" "$(green "k3s") "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then

    printf "%s\n" "$(bold "Global Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--verbose")"

    printf "    Enabling verbose Mode (set -v, print every line before it's processed)\n"

    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--xtrace")"

    printf "    Using xtrace Mode\n"

    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--unset")"

    printf "    Identifying Unset Variables\n"

    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--noerrexit")"

    printf "    No exit on error\n"

    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--noexec")"

    printf "    No exec mode. Check syntax without execution\n"

    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--debug")"

    printf "    Debugging using xtrace, verbose and unset variables modes (set -xvu)\n"

    printf "    %s\n" "Conflicts: --xtrace, --verbose, --unset"

    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--log")"

    printf "    Turn ON logging to file. \n    \n    Log file is stored in MY_LOG_DIR or in directory provided in LOG_FILE_PATH\n    argument. Log file name will be generated in format\n    './script_name-command_name.log'.\n"

    printf "    %s\n" "Conflicts: --log-file"

    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--log-file LOG-FILE-PATH")"

    printf "    Turn ON logging to file. \n    \n    Log file is stored in directory provided in LOG_FILE_PATH argument or in\n    directory from environment variable MY_LOG_DIR.\n    \n    Log file name is provided explicitly in LOG_FILE_PATH argument.\n"

    printf "    %s\n" "Conflicts: --log"

    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--framework FRAMEWORK-TYPE")"

    printf "    Framework for commands (bashmatic, bsfl).\n"

    printf "    %s\n" "Default: bashmatic"

    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"

    printf "    Show this help\n"

    echo

    printf "  %s\n" "$(magenta "--version, -v")"

    printf "    Show version number\n"

    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(cyan "MY_LOG_DIR")"

    printf "    Set your default directory for bashly script log files\n"

    echo

  fi
}

# :command.usage
vkube_exec_usage() {

  printf "vkube exec - Run 'vkube exec \"command\"'. For test traps of vkube script\n\n"

  printf "%s\n" "$(bold "Usage:")"

  printf "  vkube exec [COMMAND]\n"

  printf "  vkube exec --help | -h\n"

  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then

    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"

    printf "    Show this help\n"

    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMMAND")"

    printf "    Bash command to execute\n"

    printf "    %s\n" "Default: ls"

    echo

  fi
}

# :command.usage
vkube_all_usage() {

  printf "vkube all - Kubernetes and all services\n\n"

  printf "%s\n" "$(bold "Usage:")"

  printf "  vkube all COMMAND\n"

  printf "  vkube all [COMMAND] --help | -h\n"

  echo

  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"

  printf "  %s   Install selected kubernetes components and services\n" "$(green "install")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then

    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"

    printf "    Show this help\n"

    echo

  fi
}

# :command.usage
vkube_all_install_usage() {

  printf "vkube all install - Install selected kubernetes components and services\n\n"

  printf "%s\n" "$(bold "Usage:")"

  printf "  vkube all install PLAN_FILE\n"

  printf "  vkube all install --help | -h\n"

  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then

    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"

    printf "    Show this help\n"

    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "PLAN_FILE")"

    printf "    Cluster plan file path. Yaml file expected.\n"

    echo

  fi
}

# :command.usage
vkube_k3s_usage() {

  printf "vkube k3s - k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"

  printf "  vkube k3s COMMAND\n"

  printf "  vkube k3s [COMMAND] --help | -h\n"

  echo

  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"

  printf "  %s   Install k3s kubernetes\n" "$(green "install")  "
  printf "  %s   Uninstall k3s kubernetes\n" "$(green "uninstall")"
  printf "  %s   Upgrade k3s kubernetes\n" "$(green "upgrade")  "
  printf "  %s   Backup k3s kubernetes\n" "$(green "backup")   "
  printf "  %s   Restore k3s kubernetes\n" "$(green "restore")  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then

    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"

    printf "    Show this help\n"

    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"

    printf "  ./vkube --help\n"

    printf "  ./vkube k3s install ../k3s-HA.yaml\n"

    printf "  ./vkube k3s upgrade ../k3s-HA.yaml\n"

    printf "  ./vkube k3s backup\n"

    printf "  ./vkube k3s restore\n"

    echo

  fi
}

# :command.usage
vkube_k3s_install_usage() {

  printf "vkube k3s install - Install k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"

  printf "  vkube k3s install PLAN_FILE\n"

  printf "  vkube k3s install --help | -h\n"

  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then

    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"

    printf "    Show this help\n"

    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "PLAN_FILE")"

    printf "    Cluster plan file path. Yaml file expected.\n"

    echo

  fi
}

# :command.usage
vkube_k3s_uninstall_usage() {

  printf "vkube k3s uninstall - Uninstall k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"

  printf "  vkube k3s uninstall\n"

  printf "  vkube k3s uninstall --help | -h\n"

  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then

    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"

    printf "    Show this help\n"

    echo

  fi
}

# :command.usage
vkube_k3s_upgrade_usage() {

  printf "vkube k3s upgrade - Upgrade k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"

  printf "  vkube k3s upgrade PLAN_FILE\n"

  printf "  vkube k3s upgrade --help | -h\n"

  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then

    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"

    printf "    Show this help\n"

    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "PLAN_FILE")"

    printf "    Cluster plan file path. Yaml file expected.\n"

    echo

  fi
}

# :command.usage
vkube_k3s_backup_usage() {

  printf "vkube k3s backup - Backup k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"

  printf "  vkube k3s backup\n"

  printf "  vkube k3s backup --help | -h\n"

  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then

    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"

    printf "    Show this help\n"

    echo

  fi
}

# :command.usage
vkube_k3s_restore_usage() {

  printf "vkube k3s restore - Restore k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"

  printf "  vkube k3s restore\n"

  printf "  vkube k3s restore --help | -h\n"

  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then

    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"

    printf "    Show this help\n"

    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {

  local arg passthru flags

  passthru=false

  while [[ $# -gt 0 ]]; do

    arg="$1"

    if [[ $passthru == true ]]; then

      input+=("$arg")

    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then

      input+=("${BASH_REMATCH[1]}")

      input+=("${BASH_REMATCH[2]}")

    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then

      input+=("${BASH_REMATCH[1]}")

      input+=("${BASH_REMATCH[2]}")

    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then

      flags="${BASH_REMATCH[1]}"

      for ((i = 0; i < ${#flags}; i++)); do

        input+=("-${flags:i:1}")

      done

    elif [[ "$arg" == "--" ]]; then

      passthru=true

      input+=("$arg")

    else

      input+=("$arg")

    fi

    shift

  done

}

# :command.inspect_args
inspect_args() {

  if ((${#args[@]})); then

    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)

    echo args:

    for k in "${sorted_keys[@]}"; do

      echo "- \${args[$k]} = ${args[$k]}"

    done

  else

    echo args: none

  fi

  if ((${#deps[@]})); then

    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)

    echo

    echo deps:

    for k in "${sorted_keys[@]}"; do

      echo "- \${deps[$k]} = ${deps[$k]}"

    done

  fi

  if ((${#env_var_names[@]})); then

    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)

    echo

    echo "environment variables:"

    for k in "${sorted_names[@]}"; do

      echo "- \$$k = ${!k:-}"

    done

  fi

}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# :command.command_functions
# :command.function
vkube_exec_command() {

  # src/exec_command.sh
  #!/usr/bin/env bash
  #inspect_args
  vlib.bashly-init-command

  # shellcheck disable=SC2154
  eval "${args[command]}"

}

# :command.function
vkube_all_install_command() {

  # src/all_install_command.sh
  echo "# this file is located in 'src/all_install_command.sh'"
  echo "# code for 'vkube all install' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
vkube_k3s_install_command() {

  # src/k3s_install_command.sh
  #!/usr/bin/env bash

  # shellcheck source=/dev/null
  source "${VBASH}/vlib.bash"
  vlib.bashly-init-command
  # shellcheck source=/dev/null
  source "${VBASH}/vkube-k3s.bash"

  vkube-k3s.install

}

# :command.function
vkube_k3s_uninstall_command() {

  # src/k3s_uninstall_command.sh
  #!/usr/bin/env bash
  #inspect_args
  vlib.bashly-init-command

  # Functions
  install_tools()
  {
      # For testing purposes - in case time is wrong due to VM snapshots
      sudo timedatectl set-ntp off
      sudo timedatectl set-ntp on

      # Copy SSH certs to ~/.ssh and change permissions
      if [[ -z $cert_name ]]; then
        cp /home/$user/ssh/{$certName,$certName.pub} /home/$user/.ssh
        chmod 600 /home/$user/.ssh/$certName
        chmod 644 /home/$user/.ssh/$certName.pub
      fi

      # Install k3sup to local machine if not already present
      if ! command -v k3sup version &> /dev/null; then
        echo -e " k3sup not found, installing ..."
        curl -sLS https://get.k3sup.dev | sh
        sudo install k3sup /usr/local/bin/
      fi

      # Install Kubectl if not already present
      if ! command -v kubectl version &> /dev/null; then
        echo -e " Kubectl not found, installing ..."
        curl -LO 'https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl'
        sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
      fi

      # Install helm
      if ! command -v helm version &> /dev/null; then
        echo -e " Helm not found, installing ..."
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh
        ./get_helm.sh
        rm ./get_helm.sh
      fi

      # Install brew https://brew.sh/
      if ! command -v brew help &> /dev/null; then
        err_and_exit "Homebrew not found, please install ..."  ${LINENO} "$0"
        #/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        #run "line '$LINENO';curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh"
        #run "line '$LINENO';chmod 700 install.sh"
        #run "line '$LINENO';./install.sh"
        #run "line '$LINENO';rm ./install.sh"
      fi
  }

  gen_kube_vip_manifest()
  {
    #local version
    #run "curl -o ~/tmp/rbac.yaml https://kube-vip.io/manifests/rbac.yaml" || exit 1
    #run "scp -i ~/.ssh/$cert_name ~/tmp/rbac.yaml $node_user@$node_ip4:~/rbac.yaml" || exit 1
    #run "ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo mkdir -p /var/lib/rancher/k3s/server/manifests/'" || exit 1
    #run "ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo mv ~/rbac.yaml /var/lib/rancher/k3s/server/manifests/kube-vip-rbac.yaml'" || exit 1

    #run "ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo curl -O https://kube-vip.io/manifests/rbac.yaml'" || exit 1
    #run "ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo mkdir -p /var/lib/rancher/k3s/server/manifests/'" || exit 1
    #run "ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo mv rbac.yaml /var/lib/rancher/k3s/server/manifests/kube-vip-rbac.yaml'" || exit 1

    inf "Generate a kube-vip DaemonSet Manifest. (Line:$LINENO)"
    # https://kube-vip.io/docs/installation/daemonset/#generating-a-manifest
    # https://gist.github.com/dmancloud/3bdb3fdf2eaa3e2d42428f4a90de67a9
    #if [ "$node_id" -eq "1" ]; then
    #fi
    if [ -z $kube_vip_interface ]; then
      err_and_exit "Error: Node kube_vip_interface is empty." ${LINENO} `basename $0`
    fi

    curl -o ~/tmp/rbac.yaml https://kube-vip.io/manifests/rbac.yaml
    echo "---" >> ~/tmp/rbac.yaml
    # https://kube-vip.io/docs/installation/flags/
    if [[ "$kube_vip_mode" == "ARP" ]]; then
      #--services \
      docker run --network host --rm ghcr.io/kube-vip/kube-vip:$kube_vip_ver manifest daemonset \
      --interface $kube_vip_interface \
      --address $kube_vip_address \
      --inCluster \
      --taint \
      --controlplane \
      --services \
      --arp \
      --leaderElection \
      --enableNodeLabeling \
      >> ~/tmp/rbac.yaml
    else # BGP mode
      err_and_exit "Not implemented yet" ${LINENO}
      #--servicesElection
      docker run --network host --rm ghcr.io/kube-vip/kube-vip:$kube_vip_ver manifest daemonset \
      --interface $kube_vip_interface \
      --address $kube_vip_address \
      --inCluster \
      --taint \
      --controlplane \
      --services \
      --bgp \
      --localAS 65000 \
      --bgpRouterID 192.168.0.2 \
      --bgppeers 192.168.0.10:65000::false,192.168.0.11:65000::false
      >> ~/tmp/rbac.yaml
    fi
    if ! test -s ~/tmp/rbac.yaml; then echo "~/tmp/rbac.yaml file is empty"; echo "$LINENO"; exit 1; fi
    #while [[ $(docker inspect -f {{.State.Running}} ghcr.io/kube-vip/kube-vip:$kube_vip_ver) == "true" ]]; do
    #  sleep 1
    #done
    #if ! test -s ~/tmp/kube-vip-node.yaml; then echo "~/tmp/kube-vip-node.yaml file is empty"; fi
    scp -i ~/.ssh/$cert_name ~/tmp/rbac.yaml $node_user@$node_ip4:~/rbac.yaml
    ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S mkdir -p /var/lib/rancher/k3s/server/manifests/ <<< \"$node_root_password\"'
    ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S mv ~/rbac.yaml /var/lib/rancher/k3s/server/manifests/rbac.yaml <<< \"$node_root_password\"'
    #run "ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo mv ~/kube-vip-node.yaml /var/lib/rancher/k3s/server/manifests/kube-vip-node.yaml'" || exit 1
  }
  remove_kubernetes_first_node()
  {
    inf "Uninstalling k3s first node. (Line:$LINENO)"
    if [[ $2 -eq 1 ]]; then
      kubectl --kubeconfig ~/.kube/${cluster_name} delete daemonset kube-vip-ds -n kube-system
      rm ~/.kube/${cluster_name}
      ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S rm -f /var/lib/rancher/k3s/server/tls/* <<< \"$node_root_password\"'
    fi
    ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'if sudo -S test -e /usr/local/bin/k3s-uninstall.sh; then /usr/local/bin/k3s-uninstall.sh; fi <<< \"$node_root_password\"'
    ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S rm -rf /var/lib/rancher /etc/rancher ~/.kube/* <<< \"$node_root_password\"'
    ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S ip addr flush dev lo <<< \"$node_root_password\"'
    ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S ip addr add 127.0.0.1/8 dev lo <<< \"$node_root_password\"'
  }
  install_first_node()
  {
    if [ $opt_install_new -eq 1 ]; then
      h2 "$((++install_step)). Bootstrap First k3s node $node_name($node_ip4). (Line:$LINENO)"
    else
      h2 "$((++install_step)). Remove k3s node $node_name($node_ip4). (Line:$LINENO)"
    fi
    # https://docs.dman.cloud/tutorial-documentation/k3sup-ha/

    if ! test -e ~/.kube; then  mkdir ~/.kube;  fi
    p_exist=0
    if test -e "${HOME}/.kube/${cluster_name}"; then

      if [ $opt_install_new -eq 1 ]; then
        vlib.ask "Cluster config '${cluster_name}' already exist. Uninstall and proceed new installation?" || exit 1
      fi
      p_exist=1
      #if [ $((opt_install_new || opt_install_remove || opt_install_upgrade)) -eq 1 ]; then
      #run.ui.press-any-key "Config for cluster '${cluster_name}' already exists. Override? (^C for cancel)"
    fi
    remove_kubernetes_first_node $p_exist
      #if ! test -e ~/downloads; then mkdir ~/downloads; fi
      #if ! test -e "${HOME}/downloads/${k3s_ver}"; then

      #  mkdir "${HOME}/downloads/${k3s_ver}";
      #  run "curl -L ${url} -o ${temp_binary}"
      #fi
    # https://kube-vip.io/docs/usage/k3s/
    # [Remotely Execute Multi-line Commands with SSH](https://thornelabs.net/posts/remotely-execute-multi-line-commands-with-ssh/)
    if [ $opt_install_new -eq 1 ]; then
      # https://docs.k3s.io/cli/certificate#certificate-authority-ca-certificates
      # https://github.com/k3s-io/k3s/blob/master/contrib/util/generate-custom-ca-certs.sh
      # https://blog.chkpwd.com/posts/k3s-ha-installation-kube-vip-and-metallb/
      if ! [ $node_is_control_plane -eq 1 ]; then err_and_exit "Error: First node has to be part of Control Plane: '$k3s_settings'." ${LINENO}; fi
      cluster_node_ip=$node_ip4
      if [ $kube_vip_use -eq 1 ]; then
        gen_kube_vip_manifest
      fi
      install_k3s_cmd_parm="server \
  --token kuku \
  --cluster-init \
  --disable traefik \
  --disable servicelb \
  --write-kubeconfig-mode 644 \
  --tls-san $cluster_node_ip"
      inf "Install k3s first node. (Line:$LINENO)"
      ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'curl -fL https://get.k3s.io > ~/install.sh;chmod 777 ~/install.sh'
      ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S INSTALL_K3S_VERSION=${k3s_ver} ~/install.sh ${install_k3s_cmd_parm} <<< \"$node_root_password\"'
      #ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name "sudo -S INSTALL_K3S_VERSION=${k3s_ver} ~/install.sh ${install_k3s_cmd_parm} <<< \"$node_root_password\""
      #run "line '$LINENO';ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S curl -fL https://get.k3s.io <<< \"$node_root_password\" | INSTALL_K3S_VERSION=${k3s_ver} sh -s - ${install_k3s_cmd_parm}'"
      ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S cp /etc/rancher/k3s/k3s.yaml ~/k3s.yaml <<< \"$node_root_password\"'
      ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S chmod 777 ~/k3s.yaml <<< \"$node_root_password\"'
      scp -i ~/.ssh/$cert_name $node_user@$node_ip4:~/k3s.yaml ~/$cluster_name.yaml
      yq -i '.clusters[0].cluster.server = \"https://${cluster_node_ip}:6443\"' ~/$cluster_name.yaml
      cp ~/$cluster_name.yaml ~/.kube/$cluster_name
      #check_result $LINENO
      #run cp --backup=t ~/$cluster_name.yaml ~/.kube/$cluster_name
      chown $USER ~/.kube/$cluster_name
      #check_result $LINENO
      # https://ss64.com/bash/chmod.html
      chmod 600 ~/.kube/$cluster_name
      #check_result $LINENO
      rm ~/$cluster_name.yaml
      #check_result $LINENO
      ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'rm ~/k3s.yaml'
      #kubectl wait --for=condition=Ready node/$node_name
      #echo "cluster_token=$cluster_token"
      cluster_token="$(ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name echo \"$node_root_password\" | sudo -S cat /var/lib/rancher/k3s/server/token)"
    fi
    #while [[ $(kubectl get pods -l app=nginx -o 'jsonpath={..status.conditions[?(@.type=="Ready")].status}') != "True" ]]; do
    # sleep 1
    #done
  }

  install_join_node()
  {
    if [ $opt_install_new -eq 1 ]; then
      h2 "$((++install_step)). Join k3s node $node_name($node_ip4). (Line:$LINENO)"
    else
      h2 "$((++install_step)). Remove k3s node $node_name($node_ip4). (Line:$LINENO)"
    fi
    # https://docs.k3s.io/installation/configuration#configuration-file
  #--token $cluster_token \
    install_k3s_cmd_parm="server \
  --disable traefik \
  --disable servicelb \
  --token kuku \
  --tls-san $cluster_node_ip \
  --server https://$cluster_node_ip:6443"
    ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name  'if sudo -S test -e /usr/local/bin/k3s-uninstall.sh; then /usr/local/bin/k3s-uninstall.sh; fi <<< \"$node_root_password\"'
    ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name  'if sudo -S test -e /usr/local/bin/k3s-agent-uninstall.sh; then /usr/local/bin/k3s-agent-uninstall.sh; fi <<< \"$node_root_password\"'
    if [ $opt_install_new -eq 1 ]; then
      #run "line '$LINENO';ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'curl -fL https://get.k3s.io > ./install.sh;chmod 777 ./install.sh'"
      #run "line '$LINENO';ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'INSTALL_K3S_VERSION=${k3s_ver} sudo -S ./install.sh ${install_k3s_cmd_parm} <<< \"$node_root_password\"'"

      #K3S_URL=https://192.168.100.51:6443 K3S_TOKEN=K109836edbf7c2b660b8c7515867f6da9aa59f1c75c7e46066a78e7fb63f78a62ce::server:69a6d7584a18bf32238e6f4c5cb35624 echo qpalwoskQ4.. | sudo -S "./install.sh server --disable traefik --disable servicelb --write-kubeconfig-mode 644 --tls-san 192.168.100.50"

      ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'curl -fL https://get.k3s.io > ~/install.sh;chmod 777 ~/install.sh'
      #ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name "K3S_URL=https://$first_node_address:6443 K3S_TOKEN=$cluster_token sudo -S '$HOME/install.sh ${install_k3s_cmd_parm}' <<< \"$node_root_password\""
      #ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name "K3S_URL=https://$first_node_address:6443 K3S_TOKEN=$cluster_token sudo -S './install.sh ${install_k3s_cmd_parm}' <<< ${node_root_password}"
      #run "line '$LINENO';ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'curl -fL https://get.k3s.io > ./install.sh;chmod 777 ./install.sh'"
      #ssh vlad@192.168.100.52 -i /home/vlad/.ssh/id_rsa K3S_URL=https://192.168.100.51:6443 K3S_TOKEN=K109836edbf7c2b660b8c7515867f6da9aa59f1c75c7e46066a78e7fb63f78a62ce::server:69a6d7584a18bf32238e6f4c5cb35624 sudo -S '/home/vlad/install.sh server --disable traefik --disable servicelb --tls-san 192.168.100.50' <<< qpalwoskQ4..
    #ssh vlad@192.168.100.52 -i /home/vlad/.ssh/id_rsa INSTALL_K3S_VERSION=v1.32.2+k3s1 K3S_URL=https://192.168.100.51:6443 K3S_TOKEN=K109836edbf7c2b660b8c7515867f6da9aa59f1c75c7e46066a78e7fb63f78a62ce::server:69a6d7584a18bf32238e6f4c5cb35624 sudo -S '/home/vlad/install.sh server --disable traefik --disable servicelb --tls-san 192.168.100.50' <<< qpalwoskQ4..
    #echo ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name "INSTALL_K3S_VERSION=${k3s_ver} sudo -S ~/install.sh ${install_k3s_cmd_parm} <<< ${node_root_password}"
    #ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name "sudo -S ./install.sh ${install_k3s_cmd_parm} <<< \"$node_root_password\""
    #ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name "INSTALL_K3S_VERSION=${k3s_ver} K3S_URL=https://$first_node_address:6443 K3S_TOKEN=$cluster_token sudo -S '~/install.sh ${install_k3s_cmd_parm}' <<< ${node_root_password}"
    #ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name "INSTALL_K3S_VERSION=${k3s_ver} sudo -S ~/install.sh ${install_k3s_cmd_parm} <<< ${node_root_password}"
    ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S INSTALL_K3S_VERSION=${k3s_ver} ./install.sh ${install_k3s_cmd_parm} <<< \"$node_root_password\"'

    #run "line '$LINENO';ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'curl -fL https://get.k3s.io | K3S_URL=https://$first_node_address:6443 K3S_TOKEN=$cluster_token sudo -S sh -s - ${install_k3s_cmd_parm} <<< \"$node_root_password\"'"
    #run "line '$LINENO';ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo -S curl -fL https://get.k3s.io | K3S_URL=https://$first_node_address:6443 K3S_TOKEN=$cluster_token sh -s - ${install_k3s_cmd_parm} <<< \"$node_root_password\"'"
    #kubectl get nodes
    # sudo journalctl -xeu k3s.service # check k3s log on node
    # ls /var/lib/ca-certificates/pem
    # ls -l /etc/ssl/certs
  fi
}
wait_kubectl_can_connect_cluster()
{
  # wait until cluster is ready
  timeout=160
  timeout_step=20
  duration=0
  until kubectl get nodes > /dev/null 2>&1
  do
    sleep $timeout_step
    ((duration=duration+timeout_step))
    if [ $duration -gt $timeout ]; then

      err_and_exit "Error: Cluster is not started in $timeout seconds." ${LINENO}
    fi
  done
}


start_time=$(date +%s)
install_step=0
k3s_settings="${args[plan_file]}"

vlib.cluster_plan_read

if [[ $opt_install_remove -eq 1 ]]; then
  h2 "Remove K3s cluster with $amount_nodes nodes. Cluster plan from '$k3s_settings' file. (Line:$LINENO)"
else
  h2 "Install K3s cluster with $amount_nodes nodes. Cluster plan from '$k3s_settings' file. (Line:$LINENO)"
fi

# export KUBECONFIG=/mnt/d/dev/homelab/k3s/kubeconfig
# kubectl config use-context local
# kubectl get node -o wide

# /usr/local/bin/k3s-uninstall.sh
# /usr/local/bin/k3s-agent-uninstall.sh

install_tools

# Amount of nodes
if [[ $amount_nodes =~ ^[0-9]{1,3}$ && $amount_nodes -gt 0 ]]; then
  inf "               amount_nodes: '$amount_nodes'"
else
  err_and_exit "Error: Invalid input for amount_nodes: '$amount_nodes'." ${LINENO}
fi

amount_nodes_max=$(yq '.node | length' < $k3s_settings)
if [[ $amount_nodes -gt $amount_nodes_max ]]; then
  err_and_exit "Error: Amount of real nodes is less than requested. Real: '$amount_nodes_max', requested: '$amount_nodes'." ${LINENO}
fi

# K3S Version
k3s_latest=$(curl -sL https://api.github.com/repos/k3s-io/k3s/releases | jq -r "[ .[] | select(.prerelease == false) | .tag_name ] | sort | reverse | .[0]")
if [ -z $k3s_ver ]; then
  k3s_ver=$k3s_latest
fi
if [[ $k3s_ver =~ ^v[1-2]\.[0-9]{1,2}\.[0-9]{1,2}\+((k3s1)|(rke2))$ ]]; then
  inf "                    k3s_ver: '$k3s_ver'"
else
  err_and_exit "Error: Invalid input for k3s_ver: '$k3s_ver'." ${LINENO}
fi
if ! [ "$k3s_latest" == "$k3s_ver" ]; then
  warn "Latest version of K3s: '$k3s_latest', but installing: '$k3s_ver'"
fi

# kube vip
if [[ $kube_vip_use -eq 1 ]]; then
  #kvversion_latest=$(curl -sL https://api.github.com/repos/kube-vip/kube-vip/releases | jq -r ".[0].name")
  kvversion_latest=$(curl -sL https://api.github.com/repos/kube-vip/kube-vip/releases | jq -r "[ .[] | select(.prerelease == false) | .tag_name ] | sort | reverse | .[0]")
  if [ -z $kube_vip_ver ]; then
    kube_vip_ver=$kvversion_latest
  fi
  # Version of Kube-VIP to deploy
  if [[ $kube_vip_ver =~ ^v[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}$ ]]; then
    inf "               kube_vip_ver: '$kube_vip_ver'"
  else
    err_and_exit "Error: Invalid input for kube_vip_ver: '$kube_vip_ver'." ${LINENO}
  fi
  if ! [ "$kvversion_latest" == "$kube_vip_ver" ]; then
    warn "Latest version kube-vip: '$kvversion_latest', but installing: '$kube_vip_ver'"
  fi

  # kube-vip-cloud-provider
  #kvcloudversion_latest=$(curl -sL https://api.github.com/repos/kube-vip/kube-vip-cloud-provider/releases | jq -r "[ .[] | select(.prerelease == false) | .tag_name ] | .[0]")
  #if [ -z $kube_vip_cloud_provider_ver ]; then
  #  $kube_vip_cloud_provider_ver=$kvcloudversion_latest
  #fi
  #inf "kube_vip_cloud_provider_ver: '$kube_vip_cloud_provider_ver'\n"
  #if ! [ "$kvcloudversion_latest" == "$kube_vip_cloud_provider_ver" ]; then
  #  warn "Latest version kube-vip-cloud-provider: '$kvcloudversion_latest', but installing: '$kube_vip_cloud_provider_ver'\n"
  #fi

  # Kube-VIP mode
  if ! [[ "$kube_vip_mode" == "ARP" || "BGP" ]]; then
    err_and_exit "Error: Invalid kube_vip_mode: '$kube_vip_mode'. Expected 'ARP' or 'BGP'." ${LINENO}
  fi
  inf "              kube_vip_mode: '$kube_vip_mode'"
fi

# MetalLB
#metal_lb_latest=$(curl -sL https://api.github.com/repos/metallb/metallb/releases | jq -r ".[0].tag_name")
metal_lb_latest=$(curl -sL https://api.github.com/repos/metallb/metallb/releases | jq -r "[ .[] | select(.prerelease == false) | .tag_name ] | sort | reverse | .[0]")
if [ -z $metal_lb_ver ]; then
  $metal_lb_ver=$metal_lb_latest
fi
inf "               metal_lb_ver: '$kube_vip_cloud_provider_ver'"
if ! [ "$metal_lb_latest" == "$metal_lb_ver" ]; then
  warn "Latest version MetalLB: '$metal_lb_latest', but installing: '$metal_lb_ver'"
fi

if [ $((opt_install_new || opt_install_remove || opt_install_upgrade)) -eq 1 ]; then # install on nodes
  # Nodes
  #readarray nodes < <(yq '.nodes[] |= sort_by(.node_id)' < $k3s_settings)
  readarray nodes < <(yq -o=j -I=0 '.node[]' < $k3s_settings)

  i_node=0
  for node in "${nodes[@]}"; do
    eval "$( yq '.[] | ( select(kind == "scalar") | key + "='\''" + . + "'\''")' <<<$node)"
    #inf "          k3s_node: id='$node_id', ip4='$node_ip4', eth='$kube_vip_interface', control plane='$node_is_control_plane', worker='$node_is_worker', name='$node_name', user='$node_user'"
    # k3s installation
    if [[ $i_node -eq 0 ]]; then # first cluster node
      first_node_address=$node_ip4

      node_root_password=""
      vlib.read-password node_root_password "Please enter root password for cluster nodes:"
      echo
      #run "line '$LINENO';ssh $node_user@$node_ip4 -i ~/.ssh/$cert_name \"sudo -S rm -rfd /var/lib/kuku                                  <<< \"$node_root_password\"\""
      if [[ $first_node_address = "localhost" ]]; then
        err_and_exit "Not implemented yet" ${LINENO}
        k3sup install --local --local-path ~/.kube/local \
          --k3s-version $k3s_ver #\
          #--k3s-extra-args "--disable traefik --disable servicelb --flannel-iface=$interface --node-ip=$master1 --node-taint node-role.kubernetes.io/master=true:NoSchedule"
        inf "Updated kube config file is created: ~/.kube/local "
        inf "Config from file '~/.kube/local' is exported. Use 'ek local' to set local in KUBECONFIG env"
        inf "To uninstall: '/usr/local/bin/k3s-uninstall.sh' and may be restart computer"
      else
        install_first_node
      fi
    else # additional node join cluster
        install_join_node
    fi
    ((i_node++))
    if [ $i_node -eq $amount_nodes ]; then break; fi
  done
  if [ $opt_install_remove -eq 1 ]; then
    unset KUBECONFIG
    #rm $HOME/.kube/$cluster_name
    inf "Kubernetes cluster '$cluster_name' is uninstalled from servers described in cluster plan YAML file '$k3s_settings'"
    exit 1
  fi
  export KUBECONFIG=~/.kube/$cluster_name
  run "line '$LINENO';wait_kubectl_can_connect_cluster"
  if [ $opt_install_new -eq 1 ]; then
    inf "New kubernetes cluster '$cluster_name' is installed on servers described in cluster plan YAML file '$k3s_settings'"
    inf "To use kubectl: Run 'export KUBECONFIG=~/.kube/$cluster_name' or 'ek $cluster_name'"
  fi
  if [ $opt_install_upgrade -eq 1 ]; then
    inf "Kubernetes cluster '$cluster_name' is updated on servers described in cluster plan YAML file '$k3s_settings'"
  fi
  kubectl get nodes
fi

h2 "$((++install_step)). Install the storage drivers and classes. (Line:$LINENO)"
# if [ $csi_driver_iscsi_use -eq 1 ]; then
#   # https://www.talos.dev/v1.9/kubernetes-guides/configuration/synology-csi/
#   vlib.check-github-release-version 'csi_driver_iscsi' https://api.github.com/repos/kubernetes-csi/csi-driver-iscsi/releases 'csi_driver_iscsi_ver'
#   #echo $csi_driver_smb_ver
#   if [[ $(kubectl get pods -lapp=csi-smb-controller,app.kubernetes.io/version=$csi_driver_smb_ver -n kube-system | wc -l) -eq 0 ]]; then
#     run "line '$LINENO';helm repo add csi-driver-smb https://raw.githubusercontent.com/kubernetes-csi/csi-driver-smb/master/charts"
#     run "line '$LINENO';helm install csi-driver-smb csi-driver-smb/csi-driver-smb --namespace kube-system --version $csi_driver_smb_ver"
#     # kubectl --namespace=kube-system get pods --selector="app.kubernetes.io/name=csi-driver-smb" --watch
#   fi
# fi
if [ $csi_driver_smb_use -eq 1 ]; then
  # https://github.com/kubernetes-csi/csi-driver-smb/blob/master/deploy/example/e2e_usage.md
  # https://rguske.github.io/post/using-windows-smb-shares-in-kubernetes/
  # https://docs.aws.amazon.com/filegateway/latest/files3/use-smb-csi.html
  vlib.check-github-release-version 'csi_driver_smb' https://api.github.com/repos/kubernetes-csi/csi-driver-smb/releases 'csi_driver_smb_ver'
  #echo $csi_driver_smb_ver
  if [[ $(kubectl get pods -lapp=csi-smb-controller,app.kubernetes.io/version=$csi_driver_smb_ver -n kube-system | wc -l) -eq 0 ]]; then
    run "line '$LINENO';helm repo add csi-driver-smb https://raw.githubusercontent.com/kubernetes-csi/csi-driver-smb/master/charts"
    run "line '$LINENO';helm install csi-driver-smb csi-driver-smb/csi-driver-smb --namespace kube-system --version $csi_driver_smb_ver"
    # kubectl --namespace=kube-system get pods --selector="app.kubernetes.io/name=csi-driver-smb" --watch
  fi
  # https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/
  # https://medium.com/@ravipatel.it/mastering-kubernetes-secrets-a-comprehensive-guide-b0304818e32b
  run "line '$LINENO';kubectl create secret generic smb-csi-creds -n kube-system --from-file=$csi_driver_smb_secret_folder"
  # kubectl -n kube-system get secret smb-csi-creds -o jsonpath='{.data}'
  # kubectl -n kube-system get secret smb-csi-creds -o jsonpath='{.data.username}' | base64 --decode
  # kubectl -n kube-system get secret smb-csi-creds -o jsonpath='{.data.password}' | base64 --decode
  # kubectl -n kube-system edit secrets smb-csi-creds
  # kubectl delete secret smb-csi-creds -n kube-system
fi
if [ $csi_driver_nfs_use -eq 1 ]; then
  vlib.check-github-release-version 'csi_driver_nfs' https://api.github.com/repos/kubernetes-csi/csi-driver-nfs/releases 'csi_driver_nfs_ver'
  #echo $csi_driver_nfs_ver
  if [[ $(kubectl get pods -lapp=csi-nfs-controller,app.kubernetes.io/version=$csi_driver_nfs_ver -n kube-system | wc -l) -eq 0 ]]; then
    run "line '$LINENO';helm repo add csi-driver-nfs https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts"
    run "line '$LINENO';helm install csi-driver-nfs csi-driver-nfs/csi-driver-nfs --namespace kube-system --version $csi_driver_nfs_ver"
    # kubectl --namespace=kube-system get pods --selector="app.kubernetes.io/name=csi-driver-nfs" --watch
  fi
fi
if [ $nfs_subdir_external_provisioner_use -eq 1 ]; then
  vlib.check-github-release-version 'nfs_subdir_external_provisioner' https://api.github.com/repos/kubernetes-sigs/nfs-subdir-external-provisioner/releases 'nfs_subdir_external_provisioner_ver'
  #echo $nfs_subdir_external_provisioner_ver
  if [[ $(kubectl get pods -lapp=csi-smb-controller,app.kubernetes.io/version=$nfs_subdir_external_provisioner_ver -n kube-system | wc -l) -eq 0 ]]; then
    run "line '$LINENO';helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/"
    # helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner --namespace kube-system --set image.tag=4.0.18 --set nfs.server=192.168.100.227 --set nfs.path=/volume1/k8s-nfs-ext
    run "line '$LINENO';helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner --namespace kube-system \
      --set nfs.server=$nfs_subdir_external_provisioner_server \
      --set nfs.path=$nfs_subdir_external_provisioner_server_path"
    #  --set image.tag=$nfs_subdir_external_provisioner_ver \
    # kubectl --namespace=kube-system get pods --selector="app.kubernetes.io/name=nfs-subdir-external-provisioner" --watch
  fi
fi
run "line '$LINENO';kubectl apply -f ./storage-classes.yaml"

# https://kube-vip.io/docs/usage/cloud-provider/
# https://kube-vip.io/docs/usage/cloud-provider/#install-the-kube-vip-cloud-provider
h2 "$((++install_step)). Install the kube-vip Cloud Provider. (Line:$LINENO)"
run "line '$LINENO';kubectl apply -f https://raw.githubusercontent.com/kube-vip/kube-vip-cloud-provider/main/manifest/kube-vip-cloud-controller.yaml"
#run kubectl apply -f https://raw.githubusercontent.com/kube-vip/kube-vip-cloud-provider/$kube_vip_cloud_provider_ver/deploy/kube-vip-cloud-controller.yaml
run "line '$LINENO';kubectl create configmap -n kube-system kubevip --from-literal range-global=$kube_vip_lb_range"

# Longhorn
# https://longhorn.io/docs/1.7.2/deploy/install/install-with-kubectl/
h2 "$((++install_step)). Install Longhorn. (Line:$LINENO)"
./101-longhorn/install.sh -s "${k3s_settings}" -w "${node_root_password}" -t "${install_step}" -i $longhorn_ver

# https://wiki.musl-libc.org/building-busybox
# https://github.com/docker-library/repo-info/blob/master/repos/busybox/remote/musl.md
./102-busybox/install.sh -s "${k3s_settings}" -w "${node_root_password}" -t "${install_step}" -i $busybox_ver

# Velero backup/restore
h2 "$((++install_step)). Install Velero backup/restore. (Line:$LINENO)"
#./velero/install.sh -s "${k3s_settings}" -w "${node_root_password}" -t "${install_step}" -i $longhorn_ver
./velero/install.sh -t "${install_step}" -i $velero_ver

exit

# Rancher
h2 "$((++install_step)). Install Rancher. (Line:$LINENO)"
./105-rancher/install.sh -i $rancher_ver

# pi-hole
if [[ $pi_hole_use -eq 1 ]]; then
  h2 "$((++install_step)). Install Pi-hole. (Line:$LINENO)"
  ./101-pi-hole/install.sh -i $pi_hole_ver
fi

# longhorn_latest=$(curl -sL https://api.github.com/repos/longhorn/longhorn/releases | jq -r "[ .[] | select(.prerelease == false) | .tag_name ] | sort | reverse | .[0]")
# if [ -z $longhorn_ver ]; then
#   longhorn_ver=$longhorn_latest
# fi
# if ! [ "$longhorn_latest" == "$longhorn_ver" ]; then
#   warn "Latest version of Longhorn: '$longhorn_latest', but installing: '$longhorn_ver'\n"
# fi
# run "line '$LINENO';kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/$longhorn_ver/deploy/longhorn.yaml"
# # https://longhorn.io/docs/1.7.2/advanced-resources/longhornctl/install-longhornctl/
# if ! ($(longhornctl version > /dev/null ) || $(longhornctl version) != $longhorn_ver ); then
#   # Download the release binary.
#   run "line '$LINENO';curl -LO "https://github.com/longhorn/cli/releases/download/$longhorn_ver/longhornctl-linux-${ARCH}""
#   # Download the checksum for your architecture.
#   run line '$LINENO';curl -LO "https://github.com/longhorn/cli/releases/download/$longhorn_ver/longhornctl-linux-${ARCH}.sha256"
#   # Verify the downloaded binary matches the checksum.
#   run line '$LINENO';echo "$(cat longhornctl-linux-${ARCH}.sha256 | awk '{print $1}') longhornctl-linux-${ARCH}" | sha256sum --check
#   run line '$LINENO';sudo install longhornctl-linux-${ARCH} /usr/local/bin/longhornctl;longhornctl version
# fi

# https://argo-cd.readthedocs.io/en/stable/
hl.blue "$((++install_step)). Install Argo CD. (Line:$LINENO)"
argo_cd_latest=$(curl -sL https://api.github.com/repos/argoproj/argo-cd/releases | jq -r "[ .[] | select(.prerelease == false) | .tag_name ] | sort | reverse | .[0]")
if [ -z $argo_cd_ver ]; then
  argo_cd_ver=$argo_cd_latest
fi
if ! ($(kubectl get namespace argocd > /dev/null )); then kubectl create namespace argocd; fi
kubectl "line '$LINENO';kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/$argo_cd_ver/manifests/install.yaml"
kubectl "line '$LINENO';kubectl apply -f ./argocd/svc.yaml"

end_time=$(date +%s)
echo "Elapsed Time: $(($end_time-$start_time)) seconds"
exit

# https://ranchermanager.docs.rancher.com/getting-started/installation-and-upgrade/install-upgrade-on-a-kubernetes-cluster
hl.blue "$((++install_step)). Install Rancher. (Line:$LINENO)"
rancher_latest=$(curl -sL https://api.github.com/repos/rancher/rancher/releases | jq -r "[ .[] | select(.prerelease == false) | .tag_name ] | sort | reverse | .[0]")
if [ -z $rancher_ver ]; then
  rancher_ver=$rancher_latest
fi
helm repo add rancher-stable https://releases.rancher.com/server-charts/stable
#if ! [ "$rancher_latest" == "$rancher_ver" ]; then
#  warn "Latest version of Rancher: '$rancher_latest', but installing: '$rancher_ver'\n"
#fi
if ! ($(kubectl get namespace cattle-system > /dev/null )); then kubectl create namespace cattle-system; fi
# helm repo add rancher-stable https://releases.rancher.com/server-charts/stable
#run kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/$longhorn_ver/deploy/longhorn.yaml

hl.blue "$((++install_step)). Install Metallb. (Line:$LINENO)"
run kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.12.1/manifests/namespace.yaml
run kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/$metal_lb_ver/config/manifests/metallb-native.yaml
run kubectl wait --namespace metallb-system \
                --for=condition=ready pod \
                --selector=component=controller \
                --timeout=120s
kubectl apply -f ipAddressPool.yaml
kubectl apply -f https://raw.githubusercontent.com/JamesTurland/JimsGarage/main/Kubernetes/K3S-Deploy/l2Advertisement.yaml

kubectl get nodes
kubectl get svc
kubectl get pods --all-namespaces -o wide

exit

  run ssh -t $node_user@$node_ip4 -i ~/.ssh/$cert_name 'sudo curl -fL https://get.k3s.io | INSTALL_K3S_VERSION=${k3s_ver} sh -s - ${install_k3s_cmd_parm}'

exit

#read -p "Local K3s installation (y/n): " k3s_local_install
#if [[ "$k3s_local_install" =~ [^yn] ]]; then
#  echo "Error: Invalid input."
#  exit 1
#fi

#            DO NOT EDIT BELOW              #

exit

# Create SSH Config file to ignore checking (don't use in production!)
sed -i '1s/^/StrictHostKeyChecking no\n/' ~/.ssh/config

#add ssh keys for all nodes
for node in "${all[@]}"; do
  ssh-copy-id $user@$node
done

# Install policycoreutils for each node
for newnode in "${all[@]}"; do
  ssh $user@$newnode -i ~/.ssh/$certName sudo su <<EOF
  NEEDRESTART_MODE=a apt install policycoreutils -y
  exit
EOF
  echo -e " \033[32;5mPolicyCoreUtils installed!\033[0m"
done

# Step 1: Bootstrap First k3s Node
mkdir ~/.kube
k3sup install \
  --ip $master1 \
  --user $user \
  --tls-san $vip \
  --cluster \
  --k3s-version $k3sVersion \
  --k3s-extra-args "--disable traefik --disable servicelb --flannel-iface=$interface --node-ip=$master1 --node-taint node-role.kubernetes.io/master=true:NoSchedule" \
  --merge \
  --sudo \
  --local-path $HOME/.kube/config \
  --ssh-key $HOME/.ssh/$certName \
  --context k3s-ha
echo -e " \033[32;5mFirst Node bootstrapped successfully!\033[0m"

# Step 2: Install Kube-VIP for HA
kubectl apply -f https://kube-vip.io/manifests/rbac.yaml

# Step 3: Download kube-vip
curl -sO https://raw.githubusercontent.com/JamesTurland/JimsGarage/main/Kubernetes/K3S-Deploy/kube-vip
cat kube-vip | sed 's/$interface/'$interface'/g; s/$vip/'$vip'/g' > $HOME/kube-vip.yaml

# Step 4: Copy kube-vip.yaml to master1
scp -i ~/.ssh/$certName $HOME/kube-vip.yaml $user@$master1:~/kube-vip.yaml

# Step 5: Connect to Master1 and move kube-vip.yaml
ssh $user@$master1 -i ~/.ssh/$certName <<- EOF
  sudo mkdir -p /var/lib/rancher/k3s/server/manifests
  sudo mv kube-vip.yaml /var/lib/rancher/k3s/server/manifests/kube-vip.yaml
EOF

# Step 6: Add new master nodes (servers) & workers
for newnode in "${masters[@]}"; do
  k3sup join \
    --ip $newnode \
    --user $user \
    --sudo \
    --k3s-version $k3sVersion \
    --server \
    --server-ip $master1 \
    --ssh-key $HOME/.ssh/$certName \
    --k3s-extra-args "--disable traefik --disable servicelb --flannel-iface=$interface --node-ip=$newnode --node-taint node-role.kubernetes.io/master=true:NoSchedule" \
    --server-user $user
  echo -e " \033[32;5mMaster node joined successfully!\033[0m"
done

# add workers
for newagent in "${workers[@]}"; do
  k3sup join \
    --ip $newagent \
    --user $user \
    --sudo \
    --k3s-version $k3sVersion \
    --server-ip $master1 \
    --ssh-key $HOME/.ssh/$certName \
    --k3s-extra-args "--node-label \"longhorn=true\" --node-label \"worker=true\""
  echo -e " \033[32;5mAgent node joined successfully!\033[0m"
done

# Step 7: Install kube-vip as network LoadBalancer - Install the kube-vip Cloud Provider
kubectl apply -f https://raw.githubusercontent.com/kube-vip/kube-vip-cloud-provider/main/manifest/kube-vip-cloud-controller.yaml

# Step 8: Install Metallb
kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.12.1/manifests/namespace.yaml
kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.12/config/manifests/metallb-native.yaml
# Download ipAddressPool and configure using lbrange above
curl -sO https://raw.githubusercontent.com/JamesTurland/JimsGarage/main/Kubernetes/K3S-Deploy/ipAddressPool
cat ipAddressPool | sed 's/$lbrange/'$lbrange'/g' > $HOME/ipAddressPool.yaml

# Step 9: Test with Nginx
kubectl apply -f https://raw.githubusercontent.com/inlets/inlets-operator/master/contrib/nginx-sample-deployment.yaml -n default
kubectl expose deployment nginx-1 --port=80 --type=LoadBalancer -n default

echo -e " \033[32;5mWaiting for K3S to sync and LoadBalancer to come online\033[0m"

while [[ $(kubectl get pods -l app=nginx -o 'jsonpath={..status.conditions[?(@.type=="Ready")].status}') != "True" ]]; do
   sleep 1
done

# Step 10: Deploy IP Pools and l2Advertisement
kubectl wait --namespace metallb-system \
                --for=condition=ready pod \
                --selector=component=controller \
                --timeout=120s
kubectl apply -f ipAddressPool.yaml
kubectl apply -f https://raw.githubusercontent.com/JamesTurland/JimsGarage/main/Kubernetes/K3S-Deploy/l2Advertisement.yaml

kubectl get nodes
kubectl get svc
kubectl get pods --all-namespaces -o wide

echo -e " \033[32;5mHappy Kubing! Access Nginx at EXTERNAL-IP above\033[0m"

# Step 11: Install helm
curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
chmod 700 get_helm.sh
./get_helm.sh

# Step 12: Add Rancher Helm Repository
helm repo add rancher-latest https://releases.rancher.com/server-charts/latest
kubectl create namespace cattle-system

# Step 13: Install Cert-Manager
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.2/cert-manager.crds.yaml
helm repo add jetstack https://charts.jetstack.io
helm repo update
helm install cert-manager jetstack/cert-manager \
--namespace cert-manager \
--create-namespace \
--version v1.13.2
kubectl get pods --namespace cert-manager

# Step 14: Install Rancher
helm install rancher rancher-latest/rancher \
 --namespace cattle-system \
 --set hostname=rancher.my.org \
 --set bootstrapPassword=admin
kubectl -n cattle-system rollout status deploy/rancher
kubectl -n cattle-system get deploy rancher

# Step 15: Expose Rancher via Loadbalancer
kubectl get svc -n cattle-system
kubectl expose deployment rancher --name=rancher-lb --port=443 --type=LoadBalancer -n cattle-system
kubectl get svc -n cattle-system

# Profit: Go to Rancher GUI
echo -e " \033[32;5mHit the urlâ€¦ and create your account\033[0m"
echo -e " \033[32;5mBe patient as it downloads and configures a number of pods in the background to support the UI (can be 5-10mins)\033[0m"

# Step 16: Install Longhorn (using modified Official to pin to Longhorn Nodes)
echo -e " \033[32;5mInstalling Longhorn - It can take a while for all pods to deploy...\033[0m"
kubectl apply -f https://raw.githubusercontent.com/JamesTurland/JimsGarage/main/Kubernetes/Longhorn/longhorn.yaml
kubectl get pods \
--namespace longhorn-system \
--watch

# Step 17: Print out confirmation

kubectl get nodes
kubectl get svc -n longhorn-system

echo -e " \033[32;5mHappy Kubing! Access Longhorn through Rancher UI\033[0m"

}

# :command.function
vkube_k3s_upgrade_command() {

  # src/k3s_upgrade_command.sh
  echo "# this file is located in 'src/k3s_upgrade_command.sh'"
  echo "# code for 'vkube k3s upgrade' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
vkube_k3s_backup_command() {

  # src/k3s_backup_command.sh
  echo "# this file is located in 'src/k3s_backup_command.sh'"
  echo "# code for 'vkube k3s backup' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
vkube_k3s_restore_command() {

  # src/k3s_restore_command.sh
  echo "# this file is located in 'src/k3s_restore_command.sh'"
  echo "# code for 'vkube k3s restore' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.parse_requirements
parse_requirements() {

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      --version | -v)
        version_command

        exit

        ;;

      --help | -h)
        long_usage=yes

        vkube_usage

        exit

        ;;

      # :flag.case
      --verbose)

        # :flag.case_no_arg
        args['--verbose']=1

        shift

        ;;

      # :flag.case
      --xtrace)

        # :flag.case_no_arg
        args['--xtrace']=1

        shift

        ;;

      # :flag.case
      --unset)

        # :flag.case_no_arg
        args['--unset']=1

        shift

        ;;

      # :flag.case
      --noerrexit)

        # :flag.case_no_arg
        args['--noerrexit']=1

        shift

        ;;

      # :flag.case
      --noexec)

        # :flag.case_no_arg
        args['--noexec']=1

        shift

        ;;

      # :flag.case
      --debug)

        # :flag.conflicts
        for conflict in --xtrace --verbose --unset; do

          if [[ -n "${args[$conflict]:-}" ]]; then

            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2

            exit 1

          fi

        done

        # :flag.case_no_arg
        args['--debug']=1

        shift

        ;;

      # :flag.case
      --log)

        # :flag.conflicts
        if [[ -n "${args['--log-file']:-}" ]]; then

          printf "conflicting options: %s cannot be used with %s\n" "$key" "--log-file" >&2

          exit 1

        fi

        # :flag.case_no_arg
        args['--log']=1

        shift

        ;;

      # :flag.case
      --log-file)

        # :flag.conflicts
        if [[ -n "${args['--log']:-}" ]]; then

          printf "conflicting options: %s cannot be used with %s\n" "$key" "--log" >&2

          exit 1

        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--log-file']="$2"

          shift

          shift

        else

          printf "%s\n" "--log-file requires an argument: --log-file LOG-FILE-PATH" >&2

          exit 1

        fi

        ;;

      # :flag.case
      --framework)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--framework']="$2"

          shift

          shift

        else

          printf "%s\n" "--framework requires an argument: --framework FRAMEWORK-TYPE" >&2

          exit 1

        fi

        ;;

      *)

        break

        ;;

    esac

  done

  # :command.environment_variables_filter

  env_var_names+=("MY_LOG_DIR")

  # :command.command_filter
  action=${1:-}

  case $action in

    -*) ;;

    exec)

      action="exec"

      shift

      vkube_exec_parse_requirements "$@"

      shift $#

      ;;

    all)

      action="all"

      shift

      vkube_all_parse_requirements "$@"

      shift $#

      ;;

    k3s)

      action="k3s"

      shift

      vkube_k3s_parse_requirements "$@"

      shift $#

      ;;

    # :command.command_fallback
    "")

      vkube_usage >&2

      exit 1

      ;;

    *)

      printf "invalid command: %s\n" "$action" >&2

      exit 1

      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      -?*)

        printf "invalid option: %s\n" "$key" >&2

        exit 1

        ;;

      *)

        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2

        exit 1

        ;;

    esac

  done

  # :command.default_assignments
  [[ -n ${args['--framework']:-} ]] || args['--framework']="bashmatic"

}

# :command.parse_requirements
vkube_exec_parse_requirements() {

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      --help | -h)
        long_usage=yes

        vkube_exec_usage

        exit

        ;;

      *)

        break

        ;;

    esac

  done

  # :command.command_filter
  action="exec"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      -?*)

        printf "invalid option: %s\n" "$key" >&2

        exit 1

        ;;

      *)

        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['command']+x} ]]; then

          args['command']=$1

          shift
        else

          printf "invalid argument: %s\n" "$key" >&2

          exit 1

        fi

        ;;

    esac

  done

  # :command.default_assignments
  [[ -n ${args['command']:-} ]] || args['command']="ls"

}

# :command.parse_requirements
vkube_all_parse_requirements() {

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      --help | -h)
        long_usage=yes

        vkube_all_usage

        exit

        ;;

      *)

        break

        ;;

    esac

  done

  # :command.command_filter
  action=${1:-}

  case $action in

    -*) ;;

    install)

      action="install"

      shift

      vkube_all_install_parse_requirements "$@"

      shift $#

      ;;

    # :command.command_fallback
    "")

      vkube_all_usage >&2

      exit 1

      ;;

    *)

      printf "invalid command: %s\n" "$action" >&2

      exit 1

      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      -?*)

        printf "invalid option: %s\n" "$key" >&2

        exit 1

        ;;

      *)

        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2

        exit 1

        ;;

    esac

  done

}

# :command.parse_requirements
vkube_all_install_parse_requirements() {

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      --help | -h)
        long_usage=yes

        vkube_all_install_usage

        exit

        ;;

      *)

        break

        ;;

    esac

  done

  # :command.command_filter
  action="all install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      -?*)

        printf "invalid option: %s\n" "$key" >&2

        exit 1

        ;;

      *)

        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['plan_file']+x} ]]; then

          args['plan_file']=$1

          shift
        else

          printf "invalid argument: %s\n" "$key" >&2

          exit 1

        fi

        ;;

    esac

  done

  # :command.required_args_filter
  if [[ -z ${args['plan_file']+x} ]]; then

    printf "missing required argument: PLAN_FILE\nusage: vkube all install PLAN_FILE\n" >&2

    exit 1

  fi

}

# :command.parse_requirements
vkube_k3s_parse_requirements() {

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      --help | -h)
        long_usage=yes

        vkube_k3s_usage

        exit

        ;;

      *)

        break

        ;;

    esac

  done

  # :command.command_filter
  action=${1:-}

  case $action in

    -*) ;;

    install)

      action="install"

      shift

      vkube_k3s_install_parse_requirements "$@"

      shift $#

      ;;

    uninstall)

      action="uninstall"

      shift

      vkube_k3s_uninstall_parse_requirements "$@"

      shift $#

      ;;

    upgrade)

      action="upgrade"

      shift

      vkube_k3s_upgrade_parse_requirements "$@"

      shift $#

      ;;

    backup)

      action="backup"

      shift

      vkube_k3s_backup_parse_requirements "$@"

      shift $#

      ;;

    restore)

      action="restore"

      shift

      vkube_k3s_restore_parse_requirements "$@"

      shift $#

      ;;

    # :command.command_fallback
    "")

      vkube_k3s_usage >&2

      exit 1

      ;;

    *)

      printf "invalid command: %s\n" "$action" >&2

      exit 1

      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      -?*)

        printf "invalid option: %s\n" "$key" >&2

        exit 1

        ;;

      *)

        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2

        exit 1

        ;;

    esac

  done

}

# :command.parse_requirements
vkube_k3s_install_parse_requirements() {

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      --help | -h)
        long_usage=yes

        vkube_k3s_install_usage

        exit

        ;;

      *)

        break

        ;;

    esac

  done

  # :command.command_filter
  action="k3s install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      -?*)

        printf "invalid option: %s\n" "$key" >&2

        exit 1

        ;;

      *)

        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['plan_file']+x} ]]; then

          args['plan_file']=$1

          shift
        else

          printf "invalid argument: %s\n" "$key" >&2

          exit 1

        fi

        ;;

    esac

  done

  # :command.required_args_filter
  if [[ -z ${args['plan_file']+x} ]]; then

    printf "missing required argument: PLAN_FILE\nusage: vkube k3s install PLAN_FILE\n" >&2

    exit 1

  fi

}

# :command.parse_requirements
vkube_k3s_uninstall_parse_requirements() {

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      --help | -h)
        long_usage=yes

        vkube_k3s_uninstall_usage

        exit

        ;;

      *)

        break

        ;;

    esac

  done

  # :command.command_filter
  action="k3s uninstall"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      -?*)

        printf "invalid option: %s\n" "$key" >&2

        exit 1

        ;;

      *)

        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2

        exit 1

        ;;

    esac

  done

}

# :command.parse_requirements
vkube_k3s_upgrade_parse_requirements() {

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      --help | -h)
        long_usage=yes

        vkube_k3s_upgrade_usage

        exit

        ;;

      *)

        break

        ;;

    esac

  done

  # :command.command_filter
  action="k3s upgrade"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      -?*)

        printf "invalid option: %s\n" "$key" >&2

        exit 1

        ;;

      *)

        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['plan_file']+x} ]]; then

          args['plan_file']=$1

          shift
        else

          printf "invalid argument: %s\n" "$key" >&2

          exit 1

        fi

        ;;

    esac

  done

  # :command.required_args_filter
  if [[ -z ${args['plan_file']+x} ]]; then

    printf "missing required argument: PLAN_FILE\nusage: vkube k3s upgrade PLAN_FILE\n" >&2

    exit 1

  fi

}

# :command.parse_requirements
vkube_k3s_backup_parse_requirements() {

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      --help | -h)
        long_usage=yes

        vkube_k3s_backup_usage

        exit

        ;;

      *)

        break

        ;;

    esac

  done

  # :command.command_filter
  action="k3s backup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      -?*)

        printf "invalid option: %s\n" "$key" >&2

        exit 1

        ;;

      *)

        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2

        exit 1

        ;;

    esac

  done

}

# :command.parse_requirements
vkube_k3s_restore_parse_requirements() {

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      --help | -h)
        long_usage=yes

        vkube_k3s_restore_usage

        exit

        ;;

      *)

        break

        ;;

    esac

  done

  # :command.command_filter
  action="k3s restore"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do

    key="$1"

    case "$key" in

      -?*)

        printf "invalid option: %s\n" "$key" >&2

        exit 1

        ;;

      *)

        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2

        exit 1

        ;;

    esac

  done

}

# :command.initialize
bashly-initialize() {

  declare -g version="0.1.0"

  set -e

}

# :command.run
vkube_run() {

  # :command.globals
  declare -g long_usage=''

  declare -g -A args=()

  declare -g -A deps=()

  declare -g -a env_var_names=()

  declare -g -a input=()

  normalize_input "$@"

  parse_requirements "${input[@]}"

  case "$action" in

    "exec") vkube_exec_command ;;

    "all") vkube_all_command ;;

    "all install") vkube_all_install_command ;;

    "k3s") vkube_k3s_command ;;

    "k3s install") vkube_k3s_install_command ;;

    "k3s uninstall") vkube_k3s_uninstall_command ;;

    "k3s upgrade") vkube_k3s_upgrade_command ;;

    "k3s backup") vkube_k3s_backup_command ;;

    "k3s restore") vkube_k3s_restore_command ;;

  esac

}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then

  initialize

  vkube_run "$@"

fi


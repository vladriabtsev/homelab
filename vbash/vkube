#!/usr/bin/env bash
# This script was generated by bashly 1.2.12 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
vkube_usage() {
  printf "vkube - Kubernetes installation\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  vkube [OPTIONS] COMMAND\n"
  printf "  vkube [COMMAND] --help | -h\n"
  printf "  vkube --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   k3s kubernetes\n" "$(green "k3s") "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Global Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--force")"
    printf "    Force operation without warning\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--verbose")"
    printf "    Enabling verbose Mode (set -v, print every line before it's processed)\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--xtrace")"
    printf "    Using xtrace Mode\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--unset")"
    printf "    Identifying Unset Variables\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--noerrexit")"
    printf "    No exit on error\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--noexec")"
    printf "    No exec mode. Check syntax without execution\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--trace")"
    printf "    Trace debugging by using trace custom code in script\n"
    printf "    %s\n" "Conflicts: --debug"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--debug")"
    printf "    Debugging using xtrace, verbose and unset variables modes (set -xvu)\n"
    printf "    %s\n" "Conflicts: --xtrace, --verbose, --unset"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--log")"
    printf "    Turn ON logging to file. \n    \n    Log file is stored in MY_LOG_DIR or in directory provided in LOG_FILE_PATH\n    argument. Log file name will be generated in format\n    './script_name-command_name.log'.\n"
    printf "    %s\n" "Conflicts: --log-file"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--log-file LOG-FILE-PATH")"
    printf "    Turn ON logging to file. \n    \n    Log file is stored in directory provided in LOG_FILE_PATH argument or in\n    directory from environment variable MY_LOG_DIR.\n    \n    Log file name is provided explicitly in LOG_FILE_PATH argument.\n"
    printf "    %s\n" "Conflicts: --log"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--framework FRAMEWORK-TYPE")"
    printf "    Framework for commands (bashmatic, bsfl).\n"
    printf "    %s\n" "Default: bashmatic"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--cluster-plan CLUSTER-PLAN")"
    printf "    Cluster plan:\n    - explicit path to cluster plan yaml file\n    - or subfolder name of 'vkube-data' folder or subfolder in a current folder.\n      \n    Cluster plan folder contains:\n    - required cluster-plan.yaml file\n    - optional cluster-storage-plan.yaml file\n    - optional synology-csi subfolder\n    \n    Folder 'vkube-data' is expecting to be in a same folder as 'vkube' command\n    itself.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(magenta "--version, -v")"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(cyan "MY_LOG_DIR")"
    printf "    Set your default directory for bashly script log files\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  ./vkube --help\n"
    printf "  ./vkube k3s install k3s-HA\n"
    printf "  ./vkube k3s install ../k3s-HA.yaml\n"
    printf "  ./vkube k3s backup\n"
    printf "  ./vkube synology-csi install\n"
    echo

  fi
}

# :command.usage
vkube_exec_usage() {
  printf "vkube exec - Run 'vkube exec \"command\"'. For test traps of vkube script\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  vkube exec [COMMAND]\n"
  printf "  vkube exec --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMMAND")"
    printf "    Bash command to execute\n"
    printf "    %s\n" "Default: ls"
    echo

  fi
}

# :command.usage
vkube_k3s_usage() {
  printf "vkube k3s - k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  vkube k3s COMMAND\n"
  printf "  vkube k3s [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Install k3s kubernetes\n" "$(green "install")      "
  printf "  %s   Test speed for storage storage class\n" "$(green "storage-speed")"
  printf "  %s   Upgrade k3s kubernetes\n" "$(green "upgrade")      "
  printf "  %s   Backup k3s kubernetes\n" "$(green "backup")       "
  printf "  %s   Restore k3s kubernetes\n" "$(green "restore")      "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  ./vkube --help\n"
    printf "  ./vkube --cluster-plan k3s-HA k3s install\n"
    printf "  ./vkube --cluster-plan k3s-HA k3s install --core --storage\n"
    printf "  ./vkube --trace --cluster-plan ../k3s-HA.yaml k3s install\n"
    printf "  ./vkube --cluster-plan k3s-HA k3s install --csi-driver-smb\n"
    printf "  ./vkube --cluster-plan k3s-HA k3s install --storage-classes-only\n"
    printf "  ./vkube --cluster-plan k3s-HA k3s storage-speed --storage-class\n  office-csi-driver-smb-tmp\n"
    printf "  ./vkube --cluster-plan k3s-HA k3s storage-speed --storage-class\n  office-synology-csi-smb-tmp\n"
    printf "  ./vkube --cluster-plan k3s-HA k3s storage-speed --storage-class\n  office-synology-csi-nfs-tmp\n"
    printf "  ./vkube --cluster-plan k3s-HA k3s storage-speed --storage-class longhorn-nvme\n  --distr busybox\n"
    printf "  ./vkube k3s upgrade\n"
    printf "  ./vkube k3s backup\n"
    printf "  ./vkube k3s restore\n"
    echo

  fi
}

# :command.usage
vkube_k3s_install_usage() {
  printf "vkube k3s install - Install k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  vkube k3s install [OPTIONS]\n"
  printf "  vkube k3s install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--core")"
    printf "    Install core cluster components. Install all if --core, --storage, and\n    --apps flags are not set.\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--storage-classes-only")"
    printf "    Generate only storage classes for general storage drivers. Dangerous if\n    these classes already in use.\n"
    printf "    %s\n" "Conflicts: --storage --local --csi-driver-nfs --csi-driver-smb --csi-synology --longhorn"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--storage")"
    printf "    All general storage drivers according cluster plan.\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--local")"
    printf "    Local storage. Overriding storage use in cluster plan. Install all if\n    --core, --storage, and --apps flags are not set.\n"
    printf "    %s\n" "Conflicts: --storage"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--csi-driver-nfs")"
    printf "    CSI driver NFS storage. Overriding storage use in cluster plan. Install all\n    if --core, --storage, and --apps flags are not set.\n"
    printf "    %s\n" "Conflicts: --storage"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--csi-driver-smb")"
    printf "    CSI driver SMB storage. Overriding storage use in cluster plan. Install all\n    if --core, --storage, and --apps flags are not set.\n"
    printf "    %s\n" "Conflicts: --storage"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--csi-synology")"
    printf "    Synology CSI storage (NFS, SMB, ISCSI). Overriding storage use in cluster\n    plan. Install all if --core, --storage, and --apps flags are not set.\n"
    printf "    %s\n" "Conflicts: --storage"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--longhorn")"
    printf "    Longhorn storage. Overriding storage use in cluster plan. Install all if\n    --core, --storage, and --apps flags are not set.\n"
    printf "    %s\n" "Conflicts: --storage"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--app")"
    printf "    All applications. Overriding storage use in cluster plan. Install all if\n    --core, --storage, and --apps flags are not set.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
vkube_k3s_storage_speed_usage() {
  printf "vkube k3s storage-speed - Test speed for storage storage class\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  vkube k3s storage-speed [OPTIONS]\n"
  printf "  vkube k3s storage-speed --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--storage-class NAME (required)")"
    printf "    Storage class name\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--container-type CONTAINER")"
    printf "    Container OS\n"
    printf "    %s\n" "Allowed: alpine, ubuntu-xenial, busybox"
    printf "    %s\n" "Default: alpine"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
vkube_k3s_upgrade_usage() {
  printf "vkube k3s upgrade - Upgrade k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  vkube k3s upgrade\n"
  printf "  vkube k3s upgrade --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
vkube_k3s_backup_usage() {
  printf "vkube k3s backup - Backup k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  vkube k3s backup\n"
  printf "  vkube k3s backup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
vkube_k3s_restore_usage() {
  printf "vkube k3s restore - Restore k3s kubernetes\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  vkube k3s restore\n"
  printf "  vkube k3s restore --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/yaml.sh
yaml_load() {
  local prefix=$2
  local s='[[:space:]]*' w='[a-zA-Z0-9_]*'
  local fs

  fs=$(echo @ | tr @ '\034')

  sed -ne "s|^\($s\):|\1|" \
    -e "s|^\($s\)\($w\)$s:${s}[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
    -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |
    awk -F"$fs" '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'"$prefix"'",vn, $2, $3);
      }
    }'
}

# :command.command_functions
# :command.function
vkube_exec_command() {

  # src/exec_command.sh
  #!/usr/bin/env bash
  #inspect_args

  # shellcheck disable=SC2154
  eval "${args[command]}"

}

# :command.function
vkube_k3s_install_command() {

  # src/k3s_install_command.sh
  #!/usr/bin/env bash
  #inspect_args
  #echo "$(inspect_args)" >&3

  vlib.bashly-init-command
  vlib.trace "$(inspect_args)"

  # shellcheck source=/dev/null
  source "${VBASH}/vkube-k3s.bash"
  vkube-k3s.command-init

  #echo "      vkube-k3s.install()" >&3
  vkube-k3s.install

}

# :command.function
vkube_k3s_storage_speed_command() {

  # src/k3s_storage_speed_command.sh
  #!/usr/bin/env bash
  #inspect_args
  #echo "$(inspect_args)" >&3

  vlib.bashly-init-command
  vlib.trace "$(inspect_args)"

  # shellcheck source=/dev/null
  source "${VBASH}/vkube-k3s.bash"
  vkube-k3s.command-init

  #echo "      vkube-k3s.install()" >&3
  vkube-k3s.storage-speed-test

}

# :command.function
vkube_k3s_upgrade_command() {

  # src/k3s_upgrade_command.sh
  echo "# this file is located in 'src/k3s_upgrade_command.sh'"
  echo "# code for 'vkube k3s upgrade' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
vkube_k3s_backup_command() {

  # src/k3s_backup_command.sh
  echo "# this file is located in 'src/k3s_backup_command.sh'"
  echo "# code for 'vkube k3s backup' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
vkube_k3s_restore_command() {

  # src/k3s_restore_command.sh
  echo "# this file is located in 'src/k3s_restore_command.sh'"
  echo "# code for 'vkube k3s restore' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        vkube_usage
        exit
        ;;

      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --verbose)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      # :flag.case
      --xtrace)

        # :flag.case_no_arg
        args['--xtrace']=1
        shift
        ;;

      # :flag.case
      --unset)

        # :flag.case_no_arg
        args['--unset']=1
        shift
        ;;

      # :flag.case
      --noerrexit)

        # :flag.case_no_arg
        args['--noerrexit']=1
        shift
        ;;

      # :flag.case
      --noexec)

        # :flag.case_no_arg
        args['--noexec']=1
        shift
        ;;

      # :flag.case
      --trace)
        # :flag.conflicts
        if [[ -n "${args['--debug']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--debug" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--trace']=1
        shift
        ;;

      # :flag.case
      --debug)
        # :flag.conflicts
        for conflict in --xtrace --verbose --unset; do
          if [[ -n "${args[$conflict]:-}" ]]; then
            printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict" >&2
            exit 1
          fi
        done

        # :flag.case_no_arg
        args['--debug']=1
        shift
        ;;

      # :flag.case
      --log)
        # :flag.conflicts
        if [[ -n "${args['--log-file']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--log-file" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--log']=1
        shift
        ;;

      # :flag.case
      --log-file)
        # :flag.conflicts
        if [[ -n "${args['--log']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--log" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--log-file']="$2"
          shift
          shift
        else
          printf "%s\n" "--log-file requires an argument: --log-file LOG-FILE-PATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --framework)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--framework']="$2"
          shift
          shift
        else
          printf "%s\n" "--framework requires an argument: --framework FRAMEWORK-TYPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --cluster-plan)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--cluster-plan']="$2"
          shift
          shift
        else
          printf "%s\n" "--cluster-plan requires an argument: --cluster-plan CLUSTER-PLAN" >&2
          exit 1
        fi
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("MY_LOG_DIR")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    exec)
      action="exec"
      shift
      vkube_exec_parse_requirements "$@"
      shift $#
      ;;

    k3s)
      action="k3s"
      shift
      vkube_k3s_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      vkube_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--framework']:-} ]] || args['--framework']="bashmatic"

}

# :command.parse_requirements
vkube_exec_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        vkube_exec_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="exec"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['command']+x} ]]; then
          args['command']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['command']:-} ]] || args['command']="ls"

}

# :command.parse_requirements
vkube_k3s_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        vkube_k3s_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    install)
      action="install"
      shift
      vkube_k3s_install_parse_requirements "$@"
      shift $#
      ;;

    storage-speed)
      action="storage-speed"
      shift
      vkube_k3s_storage_speed_parse_requirements "$@"
      shift $#
      ;;

    upgrade)
      action="upgrade"
      shift
      vkube_k3s_upgrade_parse_requirements "$@"
      shift $#
      ;;

    backup)
      action="backup"
      shift
      vkube_k3s_backup_parse_requirements "$@"
      shift $#
      ;;

    restore)
      action="restore"
      shift
      vkube_k3s_restore_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      vkube_k3s_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
vkube_k3s_install_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        vkube_k3s_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="k3s install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --core)

        # :flag.case_no_arg
        args['--core']=1
        shift
        ;;

      # :flag.case
      --storage-classes-only)
        # :flag.conflicts
        if [[ -n "${args['--storage --local --csi-driver-nfs --csi-driver-smb --csi-synology --longhorn']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--storage --local --csi-driver-nfs --csi-driver-smb --csi-synology --longhorn" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--storage-classes-only']=1
        shift
        ;;

      # :flag.case
      --storage)

        # :flag.case_no_arg
        args['--storage']=1
        shift
        ;;

      # :flag.case
      --local)
        # :flag.conflicts
        if [[ -n "${args['--storage']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--storage" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      # :flag.case
      --csi-driver-nfs)
        # :flag.conflicts
        if [[ -n "${args['--storage']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--storage" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--csi-driver-nfs']=1
        shift
        ;;

      # :flag.case
      --csi-driver-smb)
        # :flag.conflicts
        if [[ -n "${args['--storage']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--storage" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--csi-driver-smb']=1
        shift
        ;;

      # :flag.case
      --csi-synology)
        # :flag.conflicts
        if [[ -n "${args['--storage']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--storage" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--csi-synology']=1
        shift
        ;;

      # :flag.case
      --longhorn)
        # :flag.conflicts
        if [[ -n "${args['--storage']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--storage" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--longhorn']=1
        shift
        ;;

      # :flag.case
      --app)

        # :flag.case_no_arg
        args['--app']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
vkube_k3s_storage_speed_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        vkube_k3s_storage_speed_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="k3s storage-speed"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --storage-class)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--storage-class']="$2"
          shift
          shift
        else
          printf "%s\n" "--storage-class requires an argument: --storage-class NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --container-type)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--container-type']="$2"
          shift
          shift
        else
          printf "%s\n" "--container-type requires an argument: --container-type CONTAINER" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--storage-class']+x} ]]; then
    printf "missing required flag: --storage-class NAME\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--container-type']:-} ]] || args['--container-type']="alpine"

  # :command.whitelist_filter
  if [[ ${args['--container-type']:-} ]] && [[ ! ${args['--container-type']:-} =~ ^(alpine|ubuntu-xenial|busybox)$ ]]; then
    printf "%s\n" "--container-type must be one of: alpine, ubuntu-xenial, busybox" >&2
    exit 1
  fi

}

# :command.parse_requirements
vkube_k3s_upgrade_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        vkube_k3s_upgrade_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="k3s upgrade"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
vkube_k3s_backup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        vkube_k3s_backup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="k3s backup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
vkube_k3s_restore_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        vkube_k3s_restore_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="k3s restore"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  #!/usr/bin/env bash
  #inspect_args

  # shellcheck source=/dev/null
  source "${VBASH}/vlib.bash"

  vkube_folder="$(dirname $0)"
  #echo $vkube_folder

}

# :command.initialize
bashly-initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
bashly-run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "exec") vkube_exec_command ;;
    "k3s") vkube_k3s_command ;;
    "k3s install") vkube_k3s_install_command ;;
    "k3s storage-speed") vkube_k3s_storage_speed_command ;;
    "k3s upgrade") vkube_k3s_upgrade_command ;;
    "k3s backup") vkube_k3s_backup_command ;;
    "k3s restore") vkube_k3s_restore_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  bashly-initialize
  bashly-run "$@"
fi
